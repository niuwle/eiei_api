Directory Structure and Files in ./app:
./app/
├── __init__.py
├── config.py
├── controllers/
│   ├── __init__.py
│   ├── ai_communication.py
│   ├── message_controller.py
│   ├── message_processing.py
│   └── telegram_integration.py
├── database.py
├── database_operations.py
├── logging_config.py
├── models/
│   ├── __init__.py
│   ├── message.py
│   └── telegram_config.py
├── scheduler.py
├── schemas.py
└── utilities.py

3 directories, 16 files

Details of Files:
Binary File: ./app/.DS_Store
___________
Start of file: ./app/config.py
# app/config.py
import os
from dotenv import load_dotenv
load_dotenv()
SQLALCHEMY_DATABASE_URL = os.getenv("SQLALCHEMY_DATABASE_URL")
OPENROUTER_TOKEN = os.getenv("OPENROUTER_TOKEN")
OPENROUTER_MODEL = os.getenv("OPENROUTER_MODEL")
OPENROUTER_URL = os.getenv("OPENROUTER_URL", "https://openrouter.ai/api/v1/chat/completions")
ASSISTANT_PROMPT = os.getenv("ASSISTANT_PROMPT")
End of file: ./app/config.py
___________
___________
Start of file: ./app/logging_config.py
# app/logging_config.py
import logging

def setup_logging():
    logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
End of file: ./app/logging_config.py
___________
___________
Start of file: ./app/database.py
#app/database.py
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
import os
from app.config import SQLALCHEMY_DATABASE_URL

engine = create_engine(SQLALCHEMY_DATABASE_URL)

SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()

# Import tbl_msg after Base and engine are created
from app.models.message import tbl_msg

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
End of file: ./app/database.py
___________
Binary File: ./app/__init__.py
___________
Start of file: ./app/models/__init__.py
    End of file: ./app/models/__init__.py
___________
___________
Start of file: ./app/models/message.py
#app/models/message.py
from sqlalchemy import Column, Integer, String, DateTime, func
from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()

class tbl_msg(Base):
    __tablename__ = 'tbl_200_messages'

    pk_messages = Column(Integer, primary_key=True, index=True)  # Changed from id to pk_messages
    channel = Column(String(100))
    bot_id = Column(Integer, nullable=False) # NOT NULL constraint specified here
    chat_id = Column(Integer)
    user_id = Column(Integer)
    type = Column(String(100))
    role = Column(String(100))
    content_text = Column(String(4000))
    file_id = Column(String(4000))
    message_date = Column(DateTime) # This matches the TIMESTAMP in your SQL
    update_id = Column(Integer)
    message_id = Column(Integer)
    is_processed = Column(String(1))
    created_by = Column(String(1000))
    created_on = Column(DateTime, default=func.now()) # Default to the current timestamp
    updated_by = Column(String(1000))
    updated_on = Column(DateTime, default=func.now(), onupdate=func.now()) # Updated timestamp on update
End of file: ./app/models/message.py
___________
___________
Start of file: ./app/models/telegram_config.py
# app/models/telegram_config.py
from sqlalchemy import Column, Integer, String, DateTime
from app.database import Base

class TelegramConfig(Base):
    __tablename__ = 'tbl_100_telegram_config'

    pk_bot = Column(Integer, primary_key=True, index=True)
    bot_name = Column(String(100))
    bot_short_name = Column(String(100))
    bot_description = Column(String(4000))
    bot_token = Column(String(4000))
    bot_assistant_prompt = Column(String(4000))
    bot_pre_prompt = Column(String(4000))
    bot_temperature = Column(Integer)
    bot_presence_penalty = Column(Integer)
    bot_frequency_penalty = Column(Integer)
    bot_default_reply = Column(String(4000))
    created_by = Column(String(1000))
    created_on = Column(DateTime)
    updated_by = Column(String(1000))
    updated_on = Column(DateTime)
End of file: ./app/models/telegram_config.py
___________
___________
Start of file: ./app/schemas.py
#app/schemas.py
from pydantic import BaseModel
from datetime import datetime

class TextMessage(BaseModel):
    chat_id: int
    user_id: int
    bot_id: int
    message_text: str
    message_id: int
    channel: str
    update_id: int
End of file: ./app/schemas.py
___________
___________
Start of file: ./app/scheduler.py
# app/scheduler.py
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from app.controllers.message_processing import check_new_messages

def setup_scheduler():
    scheduler = AsyncIOScheduler()
    scheduler.add_job(check_new_messages, 'interval', seconds=5)
    scheduler.start()
End of file: ./app/scheduler.py
___________
___________
Start of file: ./app/utilities.py
# app/utilities.py
from sqlalchemy.orm import Session
from app.models.telegram_config import TelegramConfig  # Assuming you have this model
from app.models.message import tbl_msg
from datetime import datetime

End of file: ./app/utilities.py
___________
___________
Start of file: ./app/database_operations.py
# app/database_operations.py
from sqlalchemy.orm import Session
from app.models.message import tbl_msg
from app.models.telegram_config import TelegramConfig
from datetime import datetime


def get_bot_token(bot_id: int, db: Session) -> str:
    bot_config = db.query(TelegramConfig).filter(TelegramConfig.pk_bot == bot_id).first()
    return bot_config.bot_token if bot_config else ''

def insert_response_message(db: Session, channel: str, bot_id: int, chat_id: int, content_text: str, type: str, role: str, is_processed: str):
    new_message = tbl_msg(
        channel=channel,
        bot_id=bot_id,
        chat_id=chat_id,
        type=type,
        role=role,
        content_text=content_text,
        message_date=datetime.now(),
        is_processed=is_processed
        
    )
    db.add(new_message)
    db.commit()

    
def add_message(db, message_data):
    db_message = tbl_msg(
        chat_id=message_data.chat_id,
        user_id=message_data.user_id,
        bot_id=message_data.bot_id,
        content_text=message_data.message_text,  
        message_id=message_data.message_id,
        channel=message_data.channel,
        update_id=message_data.update_id,
        message_date=datetime.now(),
        type='TEXT',
        is_processed='N',
        role='USER'
    )
    db.add(db_message)
    db.commit()
    db.refresh(db_message)
    return db_message
    
def mark_messages_processed(db: Session, chat_id: int, bot_id: int):
    messages_to_update = db.query(tbl_msg).filter(
        tbl_msg.chat_id == chat_id, 
        tbl_msg.bot_id == bot_id, 
        tbl_msg.is_processed == 'N'
    )
    for message in messages_to_update:
        message.is_processed = 'Y'
    db.commit()
End of file: ./app/database_operations.py
___________
___________
Start of file: ./app/controllers/message_controller.py
#app/controllers/message_controller.py
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from app.models.message import tbl_msg
from app.schemas import TextMessage
from app.database import get_db
from app.database_operations import add_message

router = APIRouter()

@router.post("/receive-message", status_code=status.HTTP_200_OK)
def receive_message(message: TextMessage, db: Session = Depends(get_db)):
    try:
        added_message = add_message(db, message)
        return {"pk_messages": added_message.pk_messages, "status": "Message saved successfully"}
    except Exception as e:
        # Return the error code along with the message
        raise HTTPException(status_code=400, detail=f"An error occurred while saving the message. Error: {str(e)}")
End of file: ./app/controllers/message_controller.py
___________
___________
Start of file: ./app/controllers/__init__.py
from fastapi import APIRouter
from .message_controller import router as message_router

router = APIRouter()

router.include_router(message_router)
End of file: ./app/controllers/__init__.py
___________
___________
Start of file: ./app/controllers/message_processing.py
# app/controllers/message_processing.py
import logging
from datetime import datetime, timedelta
from fastapi import Depends
from sqlalchemy.orm import Session
from app.database import get_db
from app.database_operations import get_bot_token, insert_response_message, mark_messages_processed
from app.controllers.ai_communication import get_chat_completion
from app.controllers.telegram_integration import send_telegram_message
from app.models.message import tbl_msg

def process_queue():
    db = next(get_db())
    try:
        current_time = datetime.now()
        logging.info("Processing queue at: %s", current_time)
        
        messages = db.query(tbl_msg).filter(
            tbl_msg.is_processed == 'N', 
            tbl_msg.message_date < current_time - timedelta(seconds=3)
        ).all()

        if not messages:
            logging.info("No new messages to process.")

        for message in messages:
            logging.info(f"Processing message: {message.message_id}")
            chat_id = message.chat_id
            bot_id = message.bot_id
            bot_token = get_bot_token(bot_id, db)

            response_text = get_chat_completion(chat_id, bot_id, db)
            if response_text:
                telegram_response = send_telegram_message(chat_id, response_text, bot_token)
                logging.info(f'Response from Telegram: {telegram_response}')
                insert_response_message(db, 'TELEGRAM', bot_id, chat_id, response_text,'TEXT','ASSISTANT','Y')

        # After processing all messages and sending responses, mark all messages as processed
        if messages:
            mark_messages_processed(db, chat_id, bot_id)

    except Exception as e:
        logging.error(f'Error in process_queue: {str(e)}')
        db.rollback()
        raise
    finally:
        db.close()
        logging.info("Queue processing completed.")

def check_new_messages():
    logging.info("Checking for new messages.")
    process_queue()
End of file: ./app/controllers/message_processing.py
___________
___________
Start of file: ./app/controllers/telegram_integration.py
# app/controllers/telegram_integration.py
import requests
import logging

def send_telegram_message(chat_id: int, text: str, bot_token: str) -> str:
    try:
        url = f'https://api.telegram.org/bot{bot_token}/sendMessage'
        payload = {"chat_id": chat_id, "text": text}
        response = requests.post(url, json=payload)
        return response.text
    except Exception as e:
        logging.error(f"Error sending Telegram message: {str(e)}")
        return ""
End of file: ./app/controllers/telegram_integration.py
___________
___________
Start of file: ./app/controllers/ai_communication.py
# app/controllers/ai_communication.py
import requests
import logging
from sqlalchemy.orm import Session
from app.models.message import tbl_msg
from typing import Optional
from app.config import OPENROUTER_TOKEN, OPENROUTER_MODEL, OPENROUTER_URL, ASSISTANT_PROMPT

def get_chat_completion(chat_id: int, bot_id: int, db: Session) -> Optional[str]:
    try:
        logging.info(f"Getting chat completion for chat_id: {chat_id} and bot_id: {bot_id}")
        messages = db.query(tbl_msg).filter(tbl_msg.chat_id == chat_id, tbl_msg.bot_id == bot_id).order_by(tbl_msg.message_date).all()

        payload = {"model": OPENROUTER_MODEL, "max_tokens": 4024, "messages": [{"role": "system", "content": ASSISTANT_PROMPT}]}
        for message in messages:
            payload["messages"].append({"role": message.role.lower(), "content": message.content_text})

        logging.debug("Payload for AI service: %s", payload)

        headers = {"Content-Type": "application/json", "Authorization": f"Bearer {OPENROUTER_TOKEN}"}
        response = requests.post(OPENROUTER_URL, json=payload, headers=headers)
        response_data = response.json()

        logging.info("Received response from AI service.")
        logging.debug("JSON from OpenROUTER: %s", response_data)
        return response_data.get("choices", [{}])[0].get("message", {}).get("content", "")

    except Exception as e:
        logging.error(f"Error in get_chat_completion: {str(e)}")
        return None
End of file: ./app/controllers/ai_communication.py
___________
