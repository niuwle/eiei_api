Date and Time: 28/01/2024 18.39.01
Directory Structure and Files in ./app:
./app/
├── __init__.py
├── config.py
├── controllers/
│   ├── __init__.py
│   ├── ai_communication.py
│   ├── message_processing.py
│   └── telegram_integration.py
├── database.py
├── database_operations.py
├── logging_config.py
├── models/
│   ├── __init__.py
│   ├── message.py
│   └── telegram_config.py
├── routers/
│   ├── message_controller.py
│   └── telegram_webhook.py
├── schemas.py
└── utils/
    ├── error_handler.py
    └── transcribe_audio.py

5 directories, 17 files

Details of Files:
___________
Start of file: ./app/routers/message_controller.py
# app/routers/message_controller.py
from fastapi import APIRouter, HTTPException
from app.schemas import TextMessage
from app.database import get_db
from app.database_operations import add_message
from app.controllers.message_processing import process_queue
import asyncio
from app.utils.error_handler import handle_exception 
router = APIRouter()

@router.post("/receive-message")
async def receive_message(message: TextMessage):
    async with get_db() as db:
        try:
            added_message = await add_message(db, message)
            await process_queue(added_message.chat_id, db)
            return {"pk_messages": added_message.pk_messages, "status": "Message saved successfully"}
        except Exception as e:
            handle_exception(e)End of file: ./app/routers/message_controller.py
___________
___________
Start of file: ./app/routers/telegram_webhook.py
# app/routers/telegram-webhook.py
import logging
from fastapi import APIRouter, HTTPException, Request, BackgroundTasks
from pydantic import BaseModel, Field
from app.schemas import TextMessage
from app.database import get_db
from app.database_operations import add_message, get_bot_id_by_short_name
from app.controllers.message_processing import process_queue
from app.utils.transcribe_audio import transcribe_audio
from app.utils.error_handler import handle_exception 
import os

logger = logging.getLogger(__name__)

class Voice(BaseModel):
    duration: int
    mime_type: str
    file_id: str
    file_size: int

class Message(BaseModel):
    message_id: int
    from_: dict = Field(None, alias='from')
    chat: dict
    date: int
    text: str = None  # Make text optional
    voice: Voice = None  # Add voice field

class TelegramWebhookPayload(BaseModel):
    update_id: int
    message: Message

router = APIRouter()
SECRET_TOKEN = os.getenv("TELEGRAM_SECRET_TOKEN")

@router.post("/telegram-webhook/{token}/{bot_short_name}")
async def telegram_webhook(background_tasks: BackgroundTasks, request: Request, token: str, bot_short_name: str):
    raw_body = await request.body()
    logger.info(f"Raw JSON payload: {raw_body.decode('utf-8')}")

    try:
        payload_dict = await request.json()
        payload = TelegramWebhookPayload(**payload_dict)
    except Exception as e:
        logger.error(f"Error parsing request body: {e}")
        handle_exception(e)

    if token != SECRET_TOKEN:
        raise HTTPException(status_code=403, detail="Invalid token")

    message_data = payload.message
    chat_id = message_data.chat['id']
    message_id = message_data.message_id

    async with get_db() as db:
        bot_id = await get_bot_id_by_short_name(bot_short_name, db)

        if message_data.voice:
            # Handle voice message
            internal_message = TextMessage(
                chat_id=chat_id, user_id=0, bot_id=bot_id,
                message_text="[TRANSCRIBING AUDIO]", message_id=message_id,
                channel="TELEGRAM", update_id=payload.update_id
            )
            added_message = await add_message(db, internal_message,'VOICE','N','USER')
            # Start transcription process in the background
            background_tasks.add_task(transcribe_audio,  background_tasks, added_message.pk_messages,bot_id,chat_id, message_data.voice.file_id, db)
            #background_tasks.add_task(process_queue, added_message.chat_id, db)
        elif message_data.text:
            # Handle text message
            internal_message = TextMessage(
                chat_id=chat_id, user_id=0, bot_id=bot_id,
                message_text=message_data.text, message_id=message_id,
                channel="TELEGRAM", update_id=payload.update_id
            )
            added_message = await add_message(db, internal_message,'TEXT','N','USER')
            background_tasks.add_task(process_queue, added_message.chat_id, db)
        else:
            # If neither text nor voice is found
            raise HTTPException(status_code=400, detail="Unsupported message type")

        return {"pk_messages": added_message.pk_messages, "status": "Message processed successfully"}

End of file: ./app/routers/telegram_webhook.py
___________
Binary File: ./app/.DS_Store
___________
Start of file: ./app/config.py
# app/config.py
import os
from dotenv import load_dotenv
load_dotenv()
SQLALCHEMY_DATABASE_URL = os.getenv("SQLALCHEMY_DATABASE_URL")
OPENROUTER_TOKEN = os.getenv("OPENROUTER_TOKEN")
TELEGRAM_SECRET_TOKEN = os.getenv("TELEGRAM_SECRET_TOKEN")
TELEGRAM_API_URL = os.getenv("TELEGRAM_API_URL")
OPENROUTER_MODEL = os.getenv("OPENROUTER_MODEL")
OPENROUTER_URL = os.getenv("OPENROUTER_URL", "https://openrouter.ai/api/v1/chat/completions")
ASSISTANT_PROMPT = os.getenv("ASSISTANT_PROMPT")
MONSTER_API_TOKEN = os.getenv("MONSTER_API_TOKEN")End of file: ./app/config.py
___________
___________
Start of file: ./app/logging_config.py
import logging
from logging.config import dictConfig

def setup_logging():
    logging_config = {
        'version': 1,
        'disable_existing_loggers': False,
        'formatters': {
            'standard': {
                'format': '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
            },
        },
        'handlers': {
            'default': {
                'level': 'DEBUG',
                'formatter': 'standard',
                'class': 'logging.StreamHandler',
            },
            'sqlalchemy_engine': {
                'level': 'WARN',  # Set to WARN to reduce SQL logs
                'class': 'logging.StreamHandler',
                'formatter': 'standard',
            },
        },
        'loggers': {
            '': {
                'handlers': ['default'],
                'level': 'DEBUG',
                'propagate': True
            },
            'sqlalchemy.engine': {
                'handlers': ['sqlalchemy_engine'],
                'level': 'WARN',  # Adjust this level as needed
                'propagate': False
            },
        }
    }

    dictConfig(logging_config)
End of file: ./app/logging_config.py
___________
___________
Start of file: ./app/database.py
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker
from app.config import SQLALCHEMY_DATABASE_URL
from contextlib import asynccontextmanager

if not SQLALCHEMY_DATABASE_URL:
    raise ValueError("No SQLALCHEMY_DATABASE_URL set in environment")

engine = create_async_engine(SQLALCHEMY_DATABASE_URL, echo=True)

AsyncSessionLocal = sessionmaker(
    autocommit=False,
    autoflush=False,
    bind=engine,
    class_=AsyncSession
)



@asynccontextmanager
async def get_db():
    async with AsyncSessionLocal() as session:
        yield sessionEnd of file: ./app/database.py
___________
Binary File: ./app/__init__.py
___________
Start of file: ./app/utils/error_handler.py

def handle_exception(e, status_code=500, detail=""):
    logger.error(f"Unexpected error: {str(e)}")
    raise HTTPException(status_code=status_code, detail=detail)
End of file: ./app/utils/error_handler.py
___________
___________
Start of file: ./app/utils/transcribe_audio.py
import asyncio
import httpx
import logging
import os
import mimetypes
from app.database_operations import get_bot_token, mark_message_status, update_message_content
from app.config import TELEGRAM_API_URL, MONSTER_API_TOKEN
from sqlalchemy.ext.asyncio import AsyncSession
from typing import Optional
import subprocess
import requests
from tempfile import NamedTemporaryFile
from fastapi import APIRouter, HTTPException, Request, BackgroundTasks
from app.controllers.message_processing import process_queue

logger = logging.getLogger(__name__)
async def transcribe_audio(background_tasks: BackgroundTasks,  message_pk: int, bot_id: int, chat_id: int, file_id: str, db: AsyncSession) -> Optional[str]:
    try:
        bot_token = await get_bot_token(bot_id=bot_id, db=db)
        file_url = f"{TELEGRAM_API_URL}{bot_token}/getFile?file_id={file_id}"

        async with httpx.AsyncClient() as client:
            # Get the file from Telegram
            file_response = await client.get(file_url)
            file_response.raise_for_status()

            file_path = file_response.json().get("result", {}).get("file_path", "")
            full_file_url = f"https://api.telegram.org/file/bot{bot_token}/{file_path}"

            logger.info(f"full_file_url {full_file_url}")

            # Convert audio file format
            converted_file_path = await convert_audio(full_file_url)

            # Prepare the file for upload
            file_name = os.path.basename(converted_file_path)
            files = {
                "file": (file_name, open(converted_file_path, "rb"), mimetypes.guess_type(converted_file_path)[0])
            }
            payload = {
                "diarize": "true",
                "language": "en"
            }
            headers = {
                "accept": "application/json",
                "authorization": f"Bearer {MONSTER_API_TOKEN}"
            }

            # Send the transcription request with the file
            transcription_response = await client.post(
                'https://api.monsterapi.ai/v1/generate/whisper',
                data=payload,
                files=files,
                headers=headers
            )
            logger.info(f"Monster transcription_response {transcription_response}")

            transcription_response.raise_for_status()
            transcribed_text = transcription_response.json().get('text', '')

            logger.info(f"transcribed_text {transcribed_text}")

        # Check if transcribed text is empty
        if not transcribed_text:
            error_message = "Transcription failed or returned empty result."
            logger.error(error_message)

            # Update the database with an error message
            await update_message_content(db, message_pk, error_message)

            # Mark the message status as 'E' for error
            #await mark_message_status(db, message_pk, 'E')
        else:
            logger.info(f"transcribed_text {transcribed_text}")

            # Update the database with the transcription result
            await update_message_content(db, message_pk, transcribed_text)

        # Clean up the temporary file
        os.remove(converted_file_path)

        # Continue with processing
        background_tasks.add_task(process_queue, chat_id, db)

    except Exception as e:
        logger.error(f"Error in transcribe_audio: {e}")
        await mark_message_status(db, message_pk, 'E')  # Update your function signature if needed
        return None


async def convert_audio(file_url: str) -> str:
    try:
        response = requests.get(file_url)
        if response.status_code != 200:
            logger.error('Failed to download the file')
            return ''

        with NamedTemporaryFile(suffix='.oga', delete=True) as input_file:  # Changed to delete=True for cleanup
            input_file.write(response.content)
            input_file.flush()  # Ensure all data is written

            # Convert .oga to .ogg
            output_filename = input_file.name + '.ogg'
            subprocess.run(['ffmpeg', '-i', input_file.name, output_filename], check=True)

            return output_filename

    except subprocess.CalledProcessError as e:
        logger.error(f'Failed to convert the file: {e}')
    except Exception as e:
        logger.error(f'An error occurred during audio conversion: {e}')

    return ''
End of file: ./app/utils/transcribe_audio.py
___________
___________
Start of file: ./app/models/__init__.py
from sqlalchemy.ext.declarative import declarative_base
Base = declarative_base()
End of file: ./app/models/__init__.py
___________
___________
Start of file: ./app/models/message.py
#app/models/message.py
from sqlalchemy import Column, Integer, BigInteger, String, DateTime, func
from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()

class tbl_msg(Base):
    __tablename__ = 'tbl_200_messages'

    pk_messages = Column(Integer, primary_key=True, index=True)  # Changed from id to pk_messages
    channel = Column(String(100))
    bot_id = Column(BigInteger, nullable=False) # NOT NULL constraint specified here
    chat_id = Column(BigInteger)
    user_id = Column(BigInteger)
    type = Column(String(100))
    role = Column(String(100))
    content_text = Column(String(4000))
    file_id = Column(String(4000))
    message_date = Column(DateTime) # This matches the TIMESTAMP in your SQL
    update_id = Column(BigInteger)
    message_id = Column(BigInteger)
    is_processed = Column(String(1))
    created_by = Column(String(1000))
    created_on = Column(DateTime, default=func.now()) # Default to the current timestamp
    updated_by = Column(String(1000))
    updated_on = Column(DateTime, default=func.now(), onupdate=func.now()) # Updated timestamp on update
End of file: ./app/models/message.py
___________
___________
Start of file: ./app/models/telegram_config.py
# app/models/telegram_config.py
from sqlalchemy import Column, Integer, String, DateTime
from . import Base

class TelegramConfig(Base):
    __tablename__ = 'tbl_100_telegram_config'

    pk_bot = Column(Integer, primary_key=True, index=True)
    bot_name = Column(String(100))
    bot_short_name = Column(String(100))
    bot_description = Column(String(4000))
    bot_token = Column(String(4000))
    bot_assistant_prompt = Column(String(4000))
    bot_pre_prompt = Column(String(4000))
    bot_temperature = Column(Integer)
    bot_presence_penalty = Column(Integer)
    bot_frequency_penalty = Column(Integer)
    bot_default_reply = Column(String(4000))
    created_by = Column(String(1000))
    created_on = Column(DateTime)
    updated_by = Column(String(1000))
    updated_on = Column(DateTime)
End of file: ./app/models/telegram_config.py
___________
___________
Start of file: ./app/schemas.py
#app/schemas.py
from pydantic import BaseModel
from datetime import datetime

class TextMessage(BaseModel):
    chat_id: int
    user_id: int
    bot_id: int
    message_text: str
    message_id: int
    channel: str
    update_id: int
End of file: ./app/schemas.py
___________
___________
Start of file: ./app/database_operations.py
from sqlalchemy.orm import Session
from app.models.message import tbl_msg
from app.models.telegram_config import TelegramConfig
from datetime import datetime
from sqlalchemy.future import select
from sqlalchemy.exc import SQLAlchemyError
from sqlalchemy.ext.asyncio import AsyncSession
from app.schemas import TextMessage
import logging

logger = logging.getLogger(__name__)

async def get_bot_token(bot_id: int, db: AsyncSession) -> str:
    try:
        query = select(TelegramConfig.bot_token).where(TelegramConfig.pk_bot == bot_id)
        result = await db.execute(query)
        return result.scalar_one_or_none()
    except SQLAlchemyError as e:
        logger.error(f"Database error in get_bot_token: {e}")
        return ''

async def get_bot_id_by_short_name(bot_short_name: str, db: AsyncSession) -> int:
    try:
        query = select(TelegramConfig.pk_bot).where(TelegramConfig.bot_short_name == bot_short_name)
        result = await db.execute(query)
        return result.scalar_one_or_none()
    except SQLAlchemyError as e:
        logger.error(f"Database error in get_bot_id_by_short_name: {e}")
        return None


async def add_message(db: AsyncSession, message_data: TextMessage, type: str, is_processed: str, role: str) -> tbl_msg:
    new_message = tbl_msg(
        chat_id=message_data.chat_id,
        user_id=message_data.user_id,
        bot_id=message_data.bot_id,
        content_text=message_data.message_text,
        message_id=message_data.message_id,
        channel=message_data.channel,
        update_id=message_data.update_id,
        message_date=datetime.now(),
        type=type,
        is_processed=is_processed,
        role=role
    )
    db.add(new_message)
    await db.commit()
    await db.refresh(new_message)
    logger.debug(f"Message added  {new_message}")
    return new_message

async def update_message_content(db: AsyncSession, message_pk: int, new_content: str):
    try:
        query = select(tbl_msg).where(tbl_msg.pk_messages == message_pk)
        result = await db.execute(query)
        message = result.scalar_one_or_none()
        if message:
            message.content_text = new_content
            await db.commit()
            logger.info(f"Updated content_text for message with pk {message_pk}")
        else:
            logger.warning(f"No message found with pk {message_pk}")
    except SQLAlchemyError as e:
        logger.error(f"Database error in update_message_content: {e}")
        raise

async def mark_message_status(db: AsyncSession, message_pk: int, new_status: str):
    try:
        query = select(tbl_msg).where(tbl_msg.pk_messages == message_pk)
        result = await db.execute(query)
        message = result.scalar_one_or_none()
        if message:
            message.is_processed = new_status
            await db.commit()
            logger.info(f"Message with pk {message_pk} marked as {new_status}")
        else:
            logger.warning(f"No message found with pk {message_pk}")
    except SQLAlchemyError as e:
        logger.error(f"Database error in mark_message_status: {e}")
        raise
End of file: ./app/database_operations.py
___________
___________
Start of file: ./app/controllers/__init__.py
from fastapi import APIRouter
from app.routers.message_controller import router as message_router

router = APIRouter()

router.include_router(message_router)
End of file: ./app/controllers/__init__.py
___________
___________
Start of file: ./app/controllers/message_processing.py
# ./app/controllers/message_processing.py
import logging
from datetime import datetime
from sqlalchemy.ext.asyncio import AsyncSession
from app.database_operations import get_bot_token, add_message, mark_message_status
from app.controllers.ai_communication import get_chat_completion
from app.controllers.telegram_integration import send_telegram_message
from app.models.message import tbl_msg
from app.models import message  # Ensure this is imported
from sqlalchemy.future import select
from app.schemas import TextMessage
import asyncio

logger = logging.getLogger(__name__)

async def process_queue(chat_id: int, db: AsyncSession):
    try:
        timestamp = datetime.now()
        await asyncio.sleep(3)
        logger.info(f"Processing queue for chat_id {chat_id} as of {timestamp}")

        stmt = select(tbl_msg).where(tbl_msg.chat_id == chat_id, tbl_msg.is_processed == 'N').order_by(tbl_msg.message_date.desc())
        async with db:
            result = await db.execute(stmt)
            unprocessed_messages = result.scalars().all()

        logger.info(f"Unprocessed messages: {unprocessed_messages}") 

        logger.debug(f"Unprocessed messages: {unprocessed_messages}") # Debug statement

        if unprocessed_messages:
            logger.info(f"Comparing message_date {unprocessed_messages[0].message_date} and timestamp {timestamp}")

            if unprocessed_messages[0].message_date <= timestamp:
                await process_message(unprocessed_messages, db, chat_id)
            else:
                # Skip processing as a new message arrived during the wait
                logger.info(f"Skipping processing: New message for chat_id {chat_id} arrived during wait.")
            
            
    except Exception as e:
        logger.error(f'Error processing queue: {e}')
        await db.rollback()
    finally:
        await db.close()


async def process_message(messages, db, chat_id):
    logger.debug(f"Messages to process: {messages}") # Debug statement

    # Mark all messages as processed once
    for message in messages:
        await mark_message_status(db, message.pk_messages, 'P')

    # Get chat completion only once
    try:
        response_text = await asyncio.wait_for(get_chat_completion(chat_id, messages[0].bot_id, db), timeout=10)
    except asyncio.TimeoutError:
        logger.error(f"get_chat_completion timed out for chat_id {chat_id}")
        response_text = None
        
    logger.debug(f"Chat completion response: {response_text}") # Debug statement

    if response_text:
        bot_token = await get_bot_token(messages[0].bot_id, db)
        # Send the response text to Telegram once
        await send_telegram_message(chat_id, response_text, bot_token)
        
        # Construct the message data for the response message
        response_message_data = TextMessage(
            chat_id=chat_id,
            user_id=0, # Assuming the bot is sending the message, user_id might be set to 0 or the bot's user ID
            bot_id=messages[0].bot_id,
            message_text=response_text,
            message_id=0, # If you have a way to generate or track message IDs for outgoing messages, use it here
            channel=messages[0].channel,
            update_id=0 # Set to 0 or an appropriate value if you're tracking update IDs
        )

        # Use the updated add_message function to save the response
        await add_message(db, response_message_data, type='TEXT', is_processed='Y', role='ASSISTANT')

    # Mark all messages as processed again
    for message in messages:
        await mark_message_status(db, message.pk_messages, 'Y')

    # Log the count of records processed
    logger.info(f"{len(messages)} messages processed for chat_id {chat_id}")
End of file: ./app/controllers/message_processing.py
___________
___________
Start of file: ./app/controllers/telegram_integration.py
# ./app/controllers/telegram_integration.py
import httpx
import logging
from app.config import TELEGRAM_API_URL

logger = logging.getLogger(__name__)

async def send_telegram_message(chat_id: int, text: str, bot_token: str) -> bool:
    url = f'{TELEGRAM_API_URL}{bot_token}/sendMessage'
    payload = {"chat_id": chat_id, "text": text}

    try:
        async with httpx.AsyncClient() as client:
            response = await client.post(url, json=payload)
        response.raise_for_status()
        return True
    except httpx.HTTPStatusError as e:
        logger.error(f"HTTP error sending Telegram message: {e}")
    except Exception as e:
        logger.error(f"Unexpected error in send_telegram_message: {str(e)}")
    return False
End of file: ./app/controllers/telegram_integration.py
___________
___________
Start of file: ./app/controllers/ai_communication.py
# ./app/controllers/ai_communication.py
from sqlalchemy.ext.asyncio import AsyncSession
import httpx
import logging
from app.models.message import tbl_msg
from typing import Optional
from app.config import OPENROUTER_TOKEN, OPENROUTER_MODEL, OPENROUTER_URL, ASSISTANT_PROMPT
from httpx import HTTPError
from sqlalchemy.future import select

# Create a logger
logger = logging.getLogger(__name__)

async def get_chat_completion(chat_id: int, bot_id: int, db: AsyncSession) -> Optional[str]:
    try:
        messages = await db.execute(select(tbl_msg).filter(tbl_msg.chat_id == chat_id, tbl_msg.bot_id == bot_id).order_by(tbl_msg.message_date))
        messages = messages.scalars().all()
        logger.info(f"Retrieved {len(messages)} messages for chat_id {chat_id} and bot_id {bot_id}")
        # Calculate initial payload size
        payload_size = len(str([{"role": "system", "content": ASSISTANT_PROMPT}] + [{"role": message.role.lower(), "content": message.content_text} for message in messages]))

        # Remove oldest messages if payload size exceeds 16k characters
        while payload_size > 16 * 1024:
            oldest_message = messages.pop(0)
            payload_size -= len(str({"role": oldest_message.role.lower(), "content": oldest_message.content_text}))

        payload = {
            "model": OPENROUTER_MODEL,
            "max_tokens": 4024,
            "messages": [{"role": "system", "content": ASSISTANT_PROMPT}] + [{"role": message.role.lower(), "content": message.content_text} for message in messages]
        }

        logger.debug(f"Sending JSON payload to OpenRouter: {payload}")  # Log the sent JSON payload

        async def fetch_response():
            async with httpx.AsyncClient() as client:
                response = await client.post(OPENROUTER_URL, json=payload, headers={"Authorization": f"Bearer {OPENROUTER_TOKEN}"})
            return response.json()

        response_data = await fetch_response()
        logger.info(f"Received response from OpenRouter: {response_data}")  # Log the received response

        return response_data.get("choices", [{}])[0].get("message", {}).get("content", "")

    except HTTPError as e:
        logger.error(f"HTTP error in get_chat_completion: {str(e)}")
        return None
    except Exception as e:
        logger.error(f"Unexpected error in get_chat_completion: {str(e)}")
        return None
End of file: ./app/controllers/ai_communication.py
___________
