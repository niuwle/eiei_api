Date and Time: 21/01/2024 16.25.26
Directory Structure and Files in ./app:
./app/
├── __init__.py
├── config.py
├── controllers/
│   ├── __init__.py
│   ├── ai_communication.py
│   ├── message_processing.py
│   └── telegram_integration.py
├── database.py
├── database_operations.py
├── logging_config.py
├── models/
│   ├── __init__.py
│   ├── message.py
│   └── telegram_config.py
├── routers/
│   ├── message_controller.py
│   └── telegram-webhook.py
└── schemas.py

4 directories, 15 files

Details of Files:
___________
Start of file: ./app/routers/message_controller.py
# app/routers/message_controller.py
from fastapi import APIRouter, Depends, HTTPException, status
from app.models.message import tbl_msg
from app.schemas import TextMessage
from app.database import get_db, AsyncSession
from app.database_operations import add_message
from app.controllers.message_processing import process_queue
import asyncio

router = APIRouter()

@router.post("/receive-message")
async def receive_message(message: TextMessage):
    async with get_db() as db:
        try:
            added_message = await add_message(db, message)
            await process_queue(added_message.chat_id, db)
            return {"pk_messages": added_message.pk_messages, "status": "Message saved successfully"}
        except ValueError as e:
            raise HTTPException(status_code=400, detail=f"Value error occurred: {e}")
        except HTTPException as http_err:
            raise
        except Exception as e:
            raise HTTPException(status_code=500, detail=f"An unexpected error occurred: {e}")
End of file: ./app/routers/message_controller.py
___________
___________
Start of file: ./app/routers/telegram-webhook.py
# app/routers/telegram-webhook.py
import logging
import os
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from app.schemas import TextMessage
from app.database import get_db
from app.database_operations import add_message
from pydantic import BaseModel, ValidationError

class TelegramWebhookPayload(BaseModel):
    update_id: int
    message: dict

router = APIRouter()
SECRET_TOKEN = os.getenv("TELEGRAM_SECRET_TOKEN")

@router.post("/telegram-webhook/{token}")
async def telegram_webhook(token: str, payload: TelegramWebhookPayload, db: AsyncSession = Depends(get_db)):
    try:
        if token != SECRET_TOKEN:
            logging.warning("Invalid token in webhook request")
            raise HTTPException(status_code=403, detail="Invalid token")

        if not payload.message.get('text'):
            logging.warning("No text in the message")
            raise HTTPException(status_code=400, detail="No text found in message")

        chat_id = payload.message['chat']['id']
        user_id = payload.message['from']['id']
        message_text = payload.message['text']
        message_id = payload.message['message_id']

        internal_message = TextMessage(
            chat_id=chat_id,
            user_id=user_id,
            bot_id='YOUR_BOT_ID',  # Replace with your bot's ID
            message_text=message_text,
            message_id=message_id,
            channel="TELEGRAM",
            update_id=payload.update_id
        )

        added_message = await add_message(db, internal_message)
        logging.info(f"Message processed successfully: {added_message}")
        return {"status": "Message processed successfully", "details": added_message}
    except ValidationError as ve:
        logging.error(f"Validation error: {ve}")
        raise HTTPException(status_code=422, detail=f"Validation error: {ve}")
    except HTTPException as he:
        logging.error(f"HTTP error: {he.detail}")
        raise
    except Exception as e:
        logging.error(f"Unexpected error: {e}")
        raise HTTPException(status_code=500, detail=f"An error occurred: {e}")
End of file: ./app/routers/telegram-webhook.py
___________
Binary File: ./app/.DS_Store
___________
Start of file: ./app/config.py
# app/config.py
import os
from dotenv import load_dotenv
load_dotenv()
SQLALCHEMY_DATABASE_URL = os.getenv("SQLALCHEMY_DATABASE_URL")
OPENROUTER_TOKEN = os.getenv("OPENROUTER_TOKEN")
OPENROUTER_MODEL = os.getenv("OPENROUTER_MODEL")
OPENROUTER_URL = os.getenv("OPENROUTER_URL", "https://openrouter.ai/api/v1/chat/completions")
ASSISTANT_PROMPT = os.getenv("ASSISTANT_PROMPT")
End of file: ./app/config.py
___________
___________
Start of file: ./app/logging_config.py
# app/logging_config.py
import logging

def setup_logging():
    logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
End of file: ./app/logging_config.py
___________
___________
Start of file: ./app/database.py
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker
from app.config import SQLALCHEMY_DATABASE_URL
from contextlib import asynccontextmanager

if not SQLALCHEMY_DATABASE_URL:
    raise ValueError("No SQLALCHEMY_DATABASE_URL set in environment")

engine = create_async_engine(SQLALCHEMY_DATABASE_URL, echo=True)

AsyncSessionLocal = sessionmaker(
    autocommit=False,
    autoflush=False,
    bind=engine,
    class_=AsyncSession
)



@asynccontextmanager
async def get_db():
    async with AsyncSessionLocal() as session:
        yield sessionEnd of file: ./app/database.py
___________
Binary File: ./app/__init__.py
___________
Start of file: ./app/models/__init__.py
from sqlalchemy.ext.declarative import declarative_base
Base = declarative_base()
End of file: ./app/models/__init__.py
___________
___________
Start of file: ./app/models/message.py
#app/models/message.py
from sqlalchemy import Column, Integer, String, DateTime, func
from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()

class tbl_msg(Base):
    __tablename__ = 'tbl_200_messages'

    pk_messages = Column(Integer, primary_key=True, index=True)  # Changed from id to pk_messages
    channel = Column(String(100))
    bot_id = Column(Integer, nullable=False) # NOT NULL constraint specified here
    chat_id = Column(Integer)
    user_id = Column(Integer)
    type = Column(String(100))
    role = Column(String(100))
    content_text = Column(String(4000))
    file_id = Column(String(4000))
    message_date = Column(DateTime) # This matches the TIMESTAMP in your SQL
    update_id = Column(Integer)
    message_id = Column(Integer)
    is_processed = Column(String(1))
    created_by = Column(String(1000))
    created_on = Column(DateTime, default=func.now()) # Default to the current timestamp
    updated_by = Column(String(1000))
    updated_on = Column(DateTime, default=func.now(), onupdate=func.now()) # Updated timestamp on update
End of file: ./app/models/message.py
___________
___________
Start of file: ./app/models/telegram_config.py
# app/models/telegram_config.py
from sqlalchemy import Column, Integer, String, DateTime
from . import Base

class TelegramConfig(Base):
    __tablename__ = 'tbl_100_telegram_config'

    pk_bot = Column(Integer, primary_key=True, index=True)
    bot_name = Column(String(100))
    bot_short_name = Column(String(100))
    bot_description = Column(String(4000))
    bot_token = Column(String(4000))
    bot_assistant_prompt = Column(String(4000))
    bot_pre_prompt = Column(String(4000))
    bot_temperature = Column(Integer)
    bot_presence_penalty = Column(Integer)
    bot_frequency_penalty = Column(Integer)
    bot_default_reply = Column(String(4000))
    created_by = Column(String(1000))
    created_on = Column(DateTime)
    updated_by = Column(String(1000))
    updated_on = Column(DateTime)
End of file: ./app/models/telegram_config.py
___________
___________
Start of file: ./app/schemas.py
#app/schemas.py
from pydantic import BaseModel
from datetime import datetime

class TextMessage(BaseModel):
    chat_id: int
    user_id: int
    bot_id: int
    message_text: str
    message_id: int
    channel: str
    update_id: int
End of file: ./app/schemas.py
___________
___________
Start of file: ./app/database_operations.py
from sqlalchemy.orm import Session
from app.models.message import tbl_msg
from app.models.telegram_config import TelegramConfig
from datetime import datetime
from sqlalchemy.future import select
from sqlalchemy.exc import SQLAlchemyError
from sqlalchemy.ext.asyncio import AsyncSession
from app.schemas import TextMessage
import logging

async def get_bot_token(bot_id: int, db: AsyncSession) -> str:
    try:
        result = await db.execute(select(TelegramConfig).filter(TelegramConfig.pk_bot == bot_id))
        bot_config = result.scalar_one_or_none()
        return bot_config.bot_token if bot_config else ''
    except SQLAlchemyError as e:
        logging.error(f"Database error in get_bot_token: {str(e)}")
        return ''

async def insert_response_message(db: AsyncSession, channel: str, bot_id: int, chat_id: int, content_text: str, type: str, role: str, is_processed: str):
    new_message = tbl_msg(
        channel=channel,
        bot_id=bot_id,
        chat_id=chat_id,
        type=type,
        role=role,
        content_text=content_text,
        message_date=datetime.now(),
        is_processed=is_processed
    )
    db.add(new_message)
    await db.commit()

async def add_message(db: AsyncSession, message_data: TextMessage) -> tbl_msg:
    db_message = tbl_msg(
        chat_id=message_data.chat_id,
        user_id=message_data.user_id,
        bot_id=message_data.bot_id,
        content_text=message_data.message_text,  
        message_id=message_data.message_id,
        channel=message_data.channel,
        update_id=message_data.update_id,
        message_date=datetime.now(),
        type='TEXT',
        is_processed='N',
        role='USER'
    )
    db.add(db_message)
    await db.commit()
    await db.refresh(db_message)
    return db_message

async def mark_message_status(db: AsyncSession, message_pk: int, new_status: str):
    try:
        # Retrieve the message by its primary key
        result = await db.execute(select(tbl_msg).filter(tbl_msg.pk_messages == message_pk))
        message = result.scalar_one_or_none()

        # Check if the message exists
        if message:
            # Update the is_processed status of the message
            message.is_processed = new_status
            await db.commit()
            logging.info(f"Message with pk {message_pk} marked as {new_status}")
        else:
            logging.warning(f"No message found with pk {message_pk}")

    except SQLAlchemyError as e:
        logging.error(f"Database error in mark_message_status: {str(e)}")
        raiseEnd of file: ./app/database_operations.py
___________
___________
Start of file: ./app/controllers/__init__.py
from fastapi import APIRouter
from app.routers.message_controller import router as message_router

router = APIRouter()

router.include_router(message_router)
End of file: ./app/controllers/__init__.py
___________
___________
Start of file: ./app/controllers/message_processing.py
import logging
from datetime import datetime, timedelta
from sqlalchemy.ext.asyncio import AsyncSession
from app.database_operations import get_bot_token, insert_response_message, mark_message_status
from app.controllers.ai_communication import get_chat_completion
from app.controllers.telegram_integration import send_telegram_message
from app.models.message import tbl_msg
from sqlalchemy.future import select
import asyncio

logger = logging.getLogger(__name__)

async def process_queue(chat_id: int, db: AsyncSession):
    try:
        timestamp = datetime.now()
        await asyncio.sleep(3)
        logger.info(f"Processing queue for chat_id {chat_id} as of {timestamp}")

        stmt = select(tbl_msg).where(tbl_msg.chat_id == chat_id, tbl_msg.is_processed == 'N').order_by(tbl_msg.message_date.desc())
        async with db:
            result = await db.execute(stmt)
            unprocessed_messages = result.scalars().all()

        if unprocessed_messages and unprocessed_messages[0].message_date <= timestamp:
            for message in unprocessed_messages:
                await process_message(message, db, chat_id)
        else:
            logger.info(f"No messages to process for chat_id {chat_id}")

    except Exception as e:
        logger.error(f'Error processing queue: {e}')
        await db.rollback()
    finally:
        await db.close()

async def process_message(message, db, chat_id):
    await mark_message_status(db, message.pk_messages, 'P')
    response_text = await get_chat_completion(chat_id, message.bot_id, db)

    if response_text:
        bot_token = await get_bot_token(message.bot_id, db)
        await send_telegram_message(chat_id, response_text, bot_token)
        await insert_response_message(db, 'TELEGRAM', message.bot_id, chat_id, response_text, 'TEXT', 'ASSISTANT', 'Y')

    await mark_message_status(db, message.pk_messages, 'Y')
    logger.info(f"Message {message.pk_messages} processed for chat_id {chat_id}")

End of file: ./app/controllers/message_processing.py
___________
___________
Start of file: ./app/controllers/telegram_integration.py
# ./app/controllers/telegram_integration.py
import httpx
import logging

async def send_telegram_message(chat_id: int, text: str, bot_token: str) -> str:
    try:
        url = f'https://api.telegram.org/bot{bot_token}/sendMessage'
        payload = {"chat_id": chat_id, "text": text}

        async def post_message():
            async with httpx.AsyncClient() as client:
                response = await client.post(url, json=payload)
            return response.text

        return await post_message()
    except Exception as e:
        logging.error(f"Error sending Telegram message: {str(e)}")
        return ""End of file: ./app/controllers/telegram_integration.py
___________
___________
Start of file: ./app/controllers/ai_communication.py
# ./app/controllers/ai_communication.py
from sqlalchemy.ext.asyncio import AsyncSession
import httpx
import logging
from app.models.message import tbl_msg
from typing import Optional
from app.config import OPENROUTER_TOKEN, OPENROUTER_MODEL, OPENROUTER_URL, ASSISTANT_PROMPT
from httpx import HTTPError
from sqlalchemy.future import select

# Create a logger
logger = logging.getLogger(__name__)

async def get_chat_completion(chat_id: int, bot_id: int, db: AsyncSession) -> Optional[str]:
    try:
        messages = await db.execute(select(tbl_msg).filter(tbl_msg.chat_id == chat_id, tbl_msg.bot_id == bot_id).order_by(tbl_msg.message_date))
        messages = messages.scalars().all()
        logger.info(f"Retrieved {len(messages)} messages for chat_id {chat_id} and bot_id {bot_id}")

        payload = {
            "model": OPENROUTER_MODEL,
            "max_tokens": 4024,
            "messages": [{"role": "system", "content": ASSISTANT_PROMPT}] + [{"role": message.role.lower(), "content": message.content_text} for message in messages]
        }

        logger.debug(f"Sending JSON payload to OpenRouter: {payload}")  # Log the sent JSON payload

        async def fetch_response():
            async with httpx.AsyncClient() as client:
                response = await client.post(OPENROUTER_URL, json=payload, headers={"Authorization": f"Bearer {OPENROUTER_TOKEN}"})
            return response.json()

        response_data = await fetch_response()
        logger.info(f"Received response from OpenRouter: {response_data}")  # Log the received response

        return response_data.get("choices", [{}])[0].get("message", {}).get("content", "")

    except HTTPError as e:
        logger.error(f"HTTP error in get_chat_completion: {str(e)}")
        return None
    except Exception as e:
        logger.error(f"Unexpected error in get_chat_completion: {str(e)}")
        return None
End of file: ./app/controllers/ai_communication.py
___________
